<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<<<<<<< HEAD
<meta name="generator" content="Doxygen 1.8.11"/>
=======
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
>>>>>>> upstream/master
<title>v_hdmirxss: xv_hdmirxss.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
<<<<<<< HEAD
  $(window).load(resizeHeight);
=======
>>>>>>> upstream/master
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">v_hdmirxss
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<<<<<<< HEAD
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
=======
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
>>>>>>> upstream/master
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('xv__hdmirxss_8c.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xv_hdmirxss.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<<<<<<< HEAD
<div class="textblock"><p>Please see <a class="el" href="xv__hdmirxss_8h.html" title="This is main header file of the Xilinx HDMI RX Subsystem driver. ">xv_hdmirxss.h</a> for more details of the driver.</p>
<pre>
MODIFICATION HISTORY:</pre><pre>Ver   Who    Date     Changes
----- ---- -------- -------------------------------------------------------
1.00         10/07/15 Initial release.
1.1   yh     15/01/16 Added 3D Video support
1.2   yh     20/01/16 Added remapper support
1.3   yh     01/02/16 Added set_ppc api
1.4   yh     01/02/16 Removed xil_print "Cable (dis)connected"
1.5   yh     01/02/16 Removed xil_printf("Active audio channels...)
1.6   yh     15/02/16 Added default value to XV_HdmiRxSs_ConfigRemapper
1.7   MG     03/02/16 Added HDCP support
1.8   MG     10/02/16 Moved HDCP 2.2 reset from stream up/down callback
                      to connect callback
1.9   MH     15/03/16 Added HDCP authenticated callback support
1.10  MH     23/04/16 1. HDCP 1.x driver now uses AXI timer 4.1, so updated
                      to use AXI Timer config structure to determine timer
                      clock frequency
                      2. HDCP 1.x driver has fixed the problem where the
                      reset for the receiver causes the entire DDC peripheral
                      to get reset. Based on this change the driver has been
                      updated to use XV_HdmiRxSs_HdcpReset and
                      XV_HdmiRxSs_HdcpReset functions directly.
                      3. Updated XV_HdmiRxSs_HdcpEnable and
                      XV_HdmiRxSs_HdcpEnable functions to ensure that
                      HDCP 1.4 and 2.2 are mutually exclusive.
                      This fixes the problem where HDCP 1.4 and 2.2
                      state machines are running simultaneously.
1.11  MG     13/05/16 Added DDC peripheral HDCP mode selection to XV_HdmiRxSs_HdcpEnable
1.12  MH     23/06/16 Added HDCP repeater support.
1.13  YH     18/07/16 1. Replace xil_print with xdbg_printf.
                      2. Replace MB_Sleep() with usleep()
1.14  YH     25/07/16 Used UINTPTR instead of u32 for BaseAddress
                      XV_HdmiRxSs_CfgInitialize
1.15  MH     26/07/16 Updates for automatic protocol switching
1.16  MH     05/08/16 Updates to optimize out HDCP when excluded
1.17  YH     17/08/16 Remove sleep in XV_HdmiRxSs_ResetRemapper
                      squash unused variable compiler warning
                      Added Event Log
1.18  MH     08/10/16 Improve HDCP 1.4 authentication
1.19  MG     31/10/16 Fixed issue with reference clock compensation in XV_HdmiRxSS_SetStream
</pre> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a83b64b06cb5e7c1c3736c26c19adedad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a83b64b06cb5e7c1c3736c26c19adedad">XV_HdmiRxSs_SetUserTimerHandler</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, XVidC_DelayHandler CallbackFunc, void *CallbackRef)</td></tr>
<tr class="separator:a83b64b06cb5e7c1c3736c26c19adedad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187813c9c9aa0bc87fda96af6b4b98e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a187813c9c9aa0bc87fda96af6b4b98e1">XV_HdmiRxSS_HdmiRxIntrHandler</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="separator:a187813c9c9aa0bc87fda96af6b4b98e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2419b376d0b737a59d86da1ef67bcf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#aaf2419b376d0b737a59d86da1ef67bcf">XV_HdmiRxSs_CfgInitialize</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, <a class="el" href="struct_x_v___hdmi_rx_ss___config.html">XV_HdmiRxSs_Config</a> *CfgPtr, UINTPTR EffectiveAddr)</td></tr>
<tr class="separator:aaf2419b376d0b737a59d86da1ef67bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506f350efc853af55fab90462724c5fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a506f350efc853af55fab90462724c5fd">XV_HdmiRxSs_Start</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="separator:a506f350efc853af55fab90462724c5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa499b01743a173ef1719c45cd40a79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a0fa499b01743a173ef1719c45cd40a79">XV_HdmiRxSs_Stop</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="separator:a0fa499b01743a173ef1719c45cd40a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f6e6e2ae968974f36910a74ede0e2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#ad9f6e6e2ae968974f36910a74ede0e2f">XV_HdmiRxSs_Reset</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="separator:ad9f6e6e2ae968974f36910a74ede0e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c1cbe31410b05b71e999b585a89e8c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#aa2c1cbe31410b05b71e999b585a89e8c">XV_HdmiRxSs_SetCallback</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, u32 HandlerType, void *CallbackFunc, void *CallbackRef)</td></tr>
<tr class="separator:aa2c1cbe31410b05b71e999b585a89e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277acac840c40692bcc133be2137a6e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a277acac840c40692bcc133be2137a6e6">XV_HdmiRxSs_SetEdidParam</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, u8 *EdidDataPtr, u16 Length)</td></tr>
<tr class="separator:a277acac840c40692bcc133be2137a6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158d8801dd2e574b12230ad44a1bf662"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a158d8801dd2e574b12230ad44a1bf662">XV_HdmiRxSs_LoadDefaultEdid</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="separator:a158d8801dd2e574b12230ad44a1bf662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd3689aa607f944f9eea1db1d37a2f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#abfd3689aa607f944f9eea1db1d37a2f3">XV_HdmiRxSs_LoadEdid</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, u8 *EdidDataPtr, u16 Length)</td></tr>
<tr class="separator:abfd3689aa607f944f9eea1db1d37a2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f531fa69066bf7cf1491d98b5a16e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a08f531fa69066bf7cf1491d98b5a16e0">XV_HdmiRxSs_SetHpd</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, u8 Value)</td></tr>
<tr class="separator:a08f531fa69066bf7cf1491d98b5a16e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938e999c689d01ff3559e472f21c9757"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a938e999c689d01ff3559e472f21c9757">XV_HdmiRxSs_ToggleHpd</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="separator:a938e999c689d01ff3559e472f21c9757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc5756e7c68a5abc93dc6fcb562db03"><td class="memItemLeft" align="right" valign="top">XV_HdmiRx_Aux *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#abdc5756e7c68a5abc93dc6fcb562db03">XV_HdmiRxSs_GetAuxiliary</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="separator:abdc5756e7c68a5abc93dc6fcb562db03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6156f804fb138799bb3bd9a243dd36cf"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a6156f804fb138799bb3bd9a243dd36cf">XV_HdmiRxSs_SetStream</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, u32 Clock, u32 LineRate)</td></tr>
<tr class="separator:a6156f804fb138799bb3bd9a243dd36cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4f848d7fbcea5843ae8bab4d255e2e"><td class="memItemLeft" align="right" valign="top">XVidC_VideoStream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#acf4f848d7fbcea5843ae8bab4d255e2e">XV_HdmiRxSs_GetVideoStream</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="separator:acf4f848d7fbcea5843ae8bab4d255e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd6f120b55c78fc21385878b3b930fe"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a3dd6f120b55c78fc21385878b3b930fe">XV_HdmiRxSs_GetVideoIDCode</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="separator:a3dd6f120b55c78fc21385878b3b930fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aabf114a6d9281ca99d9128a3932cdc"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a9aabf114a6d9281ca99d9128a3932cdc">XV_HdmiRxSs_GetVideoStreamType</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="separator:a9aabf114a6d9281ca99d9128a3932cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a85190f1a8a689e520e612dd2d57d8"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#ab8a85190f1a8a689e520e612dd2d57d8">XV_HdmiRxSs_GetVideoStreamScramblingFlag</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="separator:ab8a85190f1a8a689e520e612dd2d57d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9800e58c46167ce458da016451f88c8d"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a9800e58c46167ce458da016451f88c8d">XV_HdmiRxSs_GetAudioChannels</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="separator:a9800e58c46167ce458da016451f88c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc056437ab2bb79bc929f7791db5f95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#abdc056437ab2bb79bc929f7791db5f95">XV_HdmiRxSs_RefClockChangeInit</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="separator:abdc056437ab2bb79bc929f7791db5f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b31675082ff4bc8968c3f4ab5acff4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a0b31675082ff4bc8968c3f4ab5acff4a">XV_HdmiRxSs_IsStreamUp</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="separator:a0b31675082ff4bc8968c3f4ab5acff4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37eb5417ad17c232be0b46588069a330"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a37eb5417ad17c232be0b46588069a330">XV_HdmiRxSs_IsStreamConnected</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="separator:a37eb5417ad17c232be0b46588069a330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b6769e137d23ae6a4fe0d61864f5cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a93b6769e137d23ae6a4fe0d61864f5cd">XV_HdmiRxSs_SetDefaultPpc</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, u8 Id)</td></tr>
<tr class="separator:a93b6769e137d23ae6a4fe0d61864f5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7296f98d74b618438a08c0bb4d303350"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a7296f98d74b618438a08c0bb4d303350">XV_HdmiRxSs_SetPpc</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, u8 Id, u8 Ppc)</td></tr>
<tr class="separator:a7296f98d74b618438a08c0bb4d303350"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aaf2419b376d0b737a59d86da1ef67bcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XV_HdmiRxSs_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss___config.html">XV_HdmiRxSs_Config</a> *&#160;</td>
          <td class="paramname"><em>CfgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>EffectiveAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the video subsystem and included sub-cores. </p>
<p>This function must be called prior to using the subsystem. Initialization includes setting up the instance data for top level as well as all included sub-core therein, and ensuring the hardware is in a known stable state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Subsystem instance to be worked on. </td></tr>
    <tr><td class="paramname">CfgPtr</td><td>points to the configuration structure associated with the subsystem instance. </td></tr>
    <tr><td class="paramname">EffectiveAddr</td><td>is the base address of the device. If address translation is being used, then this parameter must reflect the virtual base address. Otherwise, the physical address should be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if initialization is successful else XST_FAILURE </dd></dl>

<p>References <a class="el" href="struct_x_v___hdmi_rx_ss___config.html#a63cf365a205b7f982be654194c765353">XV_HdmiRxSs_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#af4a869965ee18d575d19b4319be08ff0">XV_HdmiRxSs::Config</a>, <a class="el" href="struct_x_v___hdmi_rx_ss___config.html#a42505911ca30fec2643df7f350e0831e">XV_HdmiRxSs_Config::DeviceId</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#aba482869646bed3348cdd413cd011ee0">XV_HdmiRxSs::Hdcp14KeyPtr</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a5dc523135922e66f50ecc23b62ea8784">XV_HdmiRxSs::Hdcp22Lc128Ptr</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a7447a0e7065fc9e5c9e21a269b155d69">XV_HdmiRxSs::Hdcp22PrivateKeyPtr</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a190011d4c28960ab85152fb517b84dbf">XV_HdmiRxSs::HdcpIsReady</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#ab59a7cdab6e09550acf80932ad5838b6">XV_HdmiRxSs::IsReady</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a72aed4475f1e790c8de8526be0c2cb1d">XV_HdmiRxSs::RemapperPtr</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#adda5a89c1c0b0982984e60fe8f2e9113">XV_HdmiRxSs::RemapperResetPtr</a>, <a class="el" href="xv__hdmirxss_8h.html#a700e347f920cf2a9e9e8c29ec87b828dae1ff0bdf7f9aa784e7b74a7c9f977f3a">XV_HDMIRXSS_HDCP_14</a>, <a class="el" href="xv__hdmirxss_8h.html#a700e347f920cf2a9e9e8c29ec87b828dabb5ec86bf03fe2048919736c0030bc16">XV_HDMIRXSS_HDCP_22</a>, <a class="el" href="xv__hdmirxss_8c.html#ad9f6e6e2ae968974f36910a74ede0e2f">XV_HdmiRxSs_Reset()</a>, <a class="el" href="group__v__hdmirxss.html#gabddcd7be105900eea60e7c51158ae22d">XV_HdmiRxSs_SubcoreInitHdmiRx()</a>, <a class="el" href="group__v__hdmirxss.html#gab9f975995546d5276fee9b36a751c049">XV_HdmiRxSs_SubcoreInitRemapper()</a>, and <a class="el" href="group__v__hdmirxss.html#ga4458ec70817faa35a8acd005045a2ca6">XV_HdmiRxSs_SubcoreInitRemapperReset()</a>.</p>

</div>
</div>
<a class="anchor" id="a9800e58c46167ce458da016451f88c8d"></a>
=======
<div class="textblock"><p>This is main code of Xilinx HDMI Receiver Subsystem device driver. </p>
<p>Please see <a class="el" href="xv__hdmirxss_8h.html" title="This is main header file of the Xilinx HDMI RX Subsystem driver. ">xv_hdmirxss.h</a> for more details of the driver.</p>
<pre>
  MODIFICATION HISTORY:</pre><pre>  Ver   Who    Date     Changes
<hr/>

  1.00         10/07/15 Initial release.
  1.1   yh     15/01/16 Added 3D Video support
  1.2   yh     20/01/16 Added remapper support
  1.3   yh     01/02/16 Added set_ppc api
  1.4   yh     01/02/16 Removed xil_print "Cable (dis)connected"
  1.5   yh     01/02/16 Removed xil_printf("Active audio channels...)
  1.6   yh     15/02/16 Added default value to XV_HdmiRxSs_ConfigRemapper
  1.7   MG     03/02/16 Added HDCP support
  1.8   MG     10/02/16 Moved HDCP 2.2 reset from stream up/down callback
                        to connect callback
  1.9   MH     15/03/16 Added HDCP authenticated callback support
  1.10  MH     23/04/16 1. HDCP 1.x driver now uses AXI timer 4.1, so updated
                        to use AXI Timer config structure to determine timer
                        clock frequency
                        2. HDCP 1.x driver has fixed the problem where the
                        reset for the receiver causes the entire DDC peripheral
                        to get reset. Based on this change the driver has been
                        updated to use XV_HdmiRxSs_HdcpReset and
                        XV_HdmiRxSs_HdcpReset functions directly.
                        3. Updated XV_HdmiRxSs_HdcpEnable and
                        XV_HdmiRxSs_HdcpEnable functions to ensure that
                        HDCP 1.4 and 2.2 are mutually exclusive.
                        This fixes the problem where HDCP 1.4 and 2.2
                        state machines are running simultaneously.
  1.11  MG     13/05/16 Added DDC peripheral HDCP mode selection to XV_HdmiRxSs_HdcpEnable
  1.12  MH     23/06/16 Added HDCP repeater support.
  1.13  YH     18/07/16 1. Replace xil_print with xdbg_printf.
                        2. Replace MB_Sleep() with usleep()
  1.14  YH     25/07/16 Used UINTPTR instead of u32 for BaseAddress
                        XV_HdmiRxSs_CfgInitialize
  1.15  MH     26/07/16 Updates for automatic protocol switching
  1.16  MH     05/08/16 Updates to optimize out HDCP when excluded
  1.17  YH     17/08/16 Remove sleep in XV_HdmiRxSs_ResetRemapper
                        squash unused variable compiler warning
                        Added Event Log
  1.18  MH     08/10/16 Improve HDCP 1.4 authentication
  1.19  MG     31/10/16 Fixed issue with reference clock compensation in
                            XV_HdmiRxSS_SetStream
  1.20  YH     14/11/16 Added API to enable/disable YUV420/Pixel Drop Mode
                        for video bridge
  1.21  YH     14/11/16 Remove Remapper APIs
                        Replace XV_HdmiRxSs_ConfigRemapper API with
                        XV_HdmiRxSs_ConfigBridgeMode API as remapper feature is
                            moved to video bridge and controlled by HDMI core
  1.22  MMO    03/01/17 Add compiler option(XV_HDMIRXSS_LOG_ENABLE) to enable
                            Log
                        Move global variable XV_HdmiRx_VSIF VSIF to local
                            XV_HdmiRxSs_RetrieveVSInfoframe API
                        Move HDCP related API's to hdmirxss_hdcp.c
  1.23  MMO    10/02/17 Added Sync Loss and HDMI/DVI Interrupt Support</pre><pre>******************************************************************************/</pre><pre>/***************************** Include Files *********************************/</pre><pre><h1>100 "/proj/xhdsswstaff/vdubakul/Doxygen_Github/embeddedsw/XilinxProcessorIPLib/drivers/v_hdmirxss/src/xv_hdmirxss.c" 2</h1>
</pre><pre>
<h1>101 "/proj/xhdsswstaff/vdubakul/Doxygen_Github/embeddedsw/XilinxProcessorIPLib/drivers/v_hdmirxss/src/xv_hdmirxss.c" 2</h1>
</pre><pre></pre><pre>/************************** Constant Definitions *****************************/</pre><pre>/**************************** Type Definitions *******************************/
/**
   This typedef declares the driver instances of all the cores in the subsystem
 */
typedef struct
{</pre><pre>  XV_HdmiRx HdmiRx;
} XV_HdmiRxSs_SubCores;</pre><pre>/**************************** Local Global ***********************************/
/** Define Driver instance of all sub-core included in the design */
XV_HdmiRxSs_SubCores XV_HdmiRxSs_SubCoreRepo[XPAR_XV_HDMIRXSS_NUM_INSTANCES];</pre><pre>/************************** Function Prototypes ******************************/
static void XV_HdmiRxSs_GetIncludedSubcores(<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr,
    u16 DevId);
static void XV_HdmiRxSs_WaitUs(XV_HdmiRxSs *InstancePtr, u32 MicroSeconds);
static void XV_HdmiRxSs_RetrieveVSInfoframe(XV_HdmiRx *HdmiRxPtr);
static int XV_HdmiRxSs_RegisterSubsysCallbacks(XV_HdmiRxSs *InstancePtr);
static void XV_HdmiRxSs_ConnectCallback(void *CallbackRef);
static void XV_HdmiRxSs_AuxCallback(void *CallbackRef);
static void XV_HdmiRxSs_AudCallback(void *CallbackRef);
static void XV_HdmiRxSs_LnkStaCallback(void *CallbackRef);
static void XV_HdmiRxSs_DdcCallback(void *CallbackRef);
static void XV_HdmiRxSs_StreamDownCallback(void *CallbackRef);
static void XV_HdmiRxSs_StreamInitCallback(void *CallbackRef);
static void XV_HdmiRxSs_StreamUpCallback(void *CallbackRef);
static void XV_HdmiRxSs_SyncLossCallback(void *CallbackRef);
static void XV_HdmiRxSs_ModeCallback(void *CallbackRef);</pre><pre>static void XV_HdmiRxSs_ReportCoreInfo(XV_HdmiRxSs *InstancePtr);
static void XV_HdmiRxSs_ReportTiming(XV_HdmiRxSs *InstancePtr);
static void XV_HdmiRxSs_ReportLinkQuality(XV_HdmiRxSs *InstancePtr);
static void XV_HdmiRxSs_ReportAudio(XV_HdmiRxSs *InstancePtr);
static void XV_HdmiRxSs_ReportInfoFrame(XV_HdmiRxSs *InstancePtr);
static void <a class="el" href="xv__hdmirxss_8c.html#ab984feecc99028c5ab95d99e7087e329" title="This function prints the HDMI RX SS subcore versions. ">XV_HdmiRxSs_ReportSubcoreVersion(XV_HdmiRxSs *InstancePtr)</a>;</pre><pre>static void XV_HdmiRxSs_ConfigBridgeMode(XV_HdmiRxSs *InstancePtr);</pre><pre>/***************** Macros (Inline Functions) Definitions *********************/
/*****************************************************************************/
/**
  This macros selects the bridge YUV420 mode</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the HDMI RX Subsystem</td></tr>
  </table>
  </dd>
</dl>
*****************************************************************************/
#define XV_HdmiRxSs_BridgeYuv420(InstancePtr,Enable)</pre><pre>/*****************************************************************************/
/**
  This macros selects the bridge pixel repeat mode</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the HDMI TX Subsystem</td></tr>
  </table>
  </dd>
</dl>
*****************************************************************************/
#define XV_HdmiRxSs_BridgePixelDrop(InstancePtr,Enable)</pre><pre>/************************** Function Definition ******************************/</pre><pre>void XV_HdmiRxSs_ReportInfo(XV_HdmiRxSs *InstancePtr)
{
    xil_printf("------------\r\n");
    xil_printf("HDMI RX SubSystem\r\n");
    xil_printf("------------\r\n");
    XV_HdmiRxSs_ReportCoreInfo(InstancePtr);
    XV_HdmiRxSs_ReportSubcoreVersion(InstancePtr);
    xil_printf("\r\n");
    xil_printf("HDMI RX timing\r\n");
    xil_printf("------------\r\n");
    XV_HdmiRxSs_ReportTiming(InstancePtr);
    xil_printf("Link quality\r\n");
    xil_printf("---------\r\n");
    XV_HdmiRxSs_ReportLinkQuality(InstancePtr);
    xil_printf("Audio\r\n");
    xil_printf("---------\r\n");
    XV_HdmiRxSs_ReportAudio(InstancePtr);
    xil_printf("Infoframe\r\n");
    xil_printf("---------\r\n");
    XV_HdmiRxSs_ReportInfoFrame(InstancePtr);
    xil_printf("\r\n");
}</pre><pre>/*****************************************************************************/
/**
  This function reports list of cores included in Video Processing Subsystem</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Subsystem instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_ReportCoreInfo(XV_HdmiRxSs *InstancePtr)
{
  Xil_AssertVoid(InstancePtr != NULL);</pre><pre>  xil_printf("\r\n  -&gt;HDMI RX Subsystem Cores\r\n");</pre><pre>  /* Report all the included cores in the subsystem instance */
  if(InstancePtr-&gt;HdmiRxPtr)
  {
    xil_printf("    : HDMI RX \r\n");
  }</pre><pre>}</pre><pre>/******************************************************************************/
/**
   This function installs a custom delay/sleep function to be used by the
    <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> driver.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the HdmiSsRx instance.
</td></tr>
    <tr><td class="paramname">CallbackFunc</td><td>is the address to the callback function.
</td></tr>
    <tr><td class="paramname">CallbackRef</td><td>is the user data item (microseconds to delay) that
        will be passed to the custom sleep/delay function when it is
        invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
*******************************************************************************/
void XV_HdmiRxSs_SetUserTimerHandler(<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> <em>InstancePtr,
            XVidC_DelayHandler CallbackFunc, void *CallbackRef)
{
    /</em> Verify arguments. */
    Xil_AssertVoid(InstancePtr != NULL);
    Xil_AssertVoid(CallbackFunc != NULL);
    Xil_AssertVoid(CallbackRef != NULL);</pre><pre>    InstancePtr-&gt;UserTimerWaitUs = CallbackFunc;
    InstancePtr-&gt;UserTimerPtr = CallbackRef;
}</pre><pre>/******************************************************************************/
/**
   This function is the delay/sleep function for the <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> driver. For the
   Zynq family, there exists native sleep functionality. For MicroBlaze however,
   there does not exist such functionality. In the MicroBlaze case, the default
   method for delaying is to use a predetermined amount of loop iterations. This
   method is prone to inaccuracy and dependent on system configuration; for
   greater accuracy, the user may supply their own delay/sleep handler, pointed
   to by InstancePtr-&gt;UserTimerWaitUs, which may have better accuracy if a
   hardware timer is used.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the HdmiSsRx instance.
</td></tr>
    <tr><td class="paramname">MicroSeconds</td><td>is the number of microseconds to delay/sleep for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
*******************************************************************************/
static void XV_HdmiRxSs_WaitUs(XV_HdmiRxSs &lt;em&gt;InstancePtr, u32 MicroSeconds)
{
    / Verify arguments. */
    Xil_AssertVoid(InstancePtr != NULL);
    Xil_AssertVoid(InstancePtr-&gt;IsReady == XIL_COMPONENT_IS_READY);</pre><pre>    if (MicroSeconds == 0) {
        return;
    }</pre><pre>    if (InstancePtr-&gt;UserTimerWaitUs != NULL) {
        /* Use the timer handler specified by the user for better
           accuracy. */
        InstancePtr-&gt;UserTimerWaitUs(InstancePtr, MicroSeconds);
    }
    else {
        usleep(MicroSeconds);
    }
}</pre><pre>/*****************************************************************************/
/**
   This function calls the interrupt handler for HDMI RX</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the HDMI RX Subsystem</td></tr>
  </table>
  </dd>
</dl>
*****************************************************************************/
void XV_HdmiRxSS_HdmiRxIntrHandler(XV_HdmiRxSs *InstancePtr)
{
    XV_HdmiRx_IntrHandler(InstancePtr-&gt;HdmiRxPtr);
}</pre><pre>/*****************************************************************************/
/**
   This function register's all sub-core ISR's with interrupt controller and
   any subsystem level call back function with requisite sub-core</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Subsystem instance to be
         worked on.</td></tr>
  </table>
  </dd>
</dl>
*****************************************************************************/
static int XV_HdmiRxSs_RegisterSubsysCallbacks(XV_HdmiRxSs *InstancePtr)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = InstancePtr;</pre><pre>  //Register HDMI callbacks
  if(HdmiRxSsPtr-&gt;HdmiRxPtr) {
    /*
       Register call back for Rx Core Interrupts.
     */
    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_CONNECT,
                          (void *)XV_HdmiRxSs_ConnectCallback,
                                                  (void *)InstancePtr);</pre><pre>    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_AUX,
                                                  (void *)XV_HdmiRxSs_AuxCallback,
                                                  (void *)InstancePtr);</pre><pre>    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_AUD,
                                                  (void *)XV_HdmiRxSs_AudCallback,
                                                  (void *)InstancePtr);</pre><pre>    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_LNKSTA,
                                                  (void *)XV_HdmiRxSs_LnkStaCallback,
                                                  (void *)InstancePtr);</pre><pre>    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_DDC,
                                                  (void *)XV_HdmiRxSs_DdcCallback,
                                                  (void *)InstancePtr);</pre><pre>    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_STREAM_DOWN,
                                                  (void *)XV_HdmiRxSs_StreamDownCallback,
                                                  (void *)InstancePtr);</pre><pre>    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_STREAM_INIT,
                                                  (void *)XV_HdmiRxSs_StreamInitCallback,
                                                  (void *)InstancePtr);</pre><pre>    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_STREAM_UP,
                                                  (void *)XV_HdmiRxSs_StreamUpCallback,
                                                  (void *)InstancePtr);</pre><pre>    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_SYNC_LOSS,
                                                  (void *)XV_HdmiRxSs_SyncLossCallback,
                                                  (void *)InstancePtr);</pre><pre>    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_MODE,
                                                  (void *)XV_HdmiRxSs_ModeCallback,
                                                  (void *)InstancePtr);
  }</pre><pre>  return(XST_SUCCESS);
}</pre><pre>/*****************************************************************************/
/**
  This function queries the subsystem instance configuration to determine
  the included sub-cores. For each sub-core that is present in the design
  the sub-core driver instance is binded with the subsystem sub-core driver
  handle</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">HdmiRxSsPtr</td><td>is a pointer to the Subsystem instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_GetIncludedSubcores(XV_HdmiRxSs *HdmiRxSsPtr, u16 DevId)
{
  HdmiRxSsPtr-&gt;HdmiRxPtr   =((HdmiRxSsPtr-&gt;Config.HdmiRx.IsPresent) ?
                            (&amp;XV_HdmiRxSs_SubCoreRepo[DevId].HdmiRx) : NULL);</pre><pre>}</pre><pre>/*****************************************************************************/
/**
  This function initializes the video subsystem and included sub-cores.
  This function must be called prior to using the subsystem. Initialization
  includes setting up the instance data for top level as well as all included
  sub-core therein, and ensuring the hardware is in a known stable state.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Subsystem instance to be worked on.
</td></tr>
    <tr><td class="paramname">CfgPtr</td><td>points to the configuration structure associated with the
          subsystem instance.
</td></tr>
    <tr><td class="paramname">EffectiveAddr</td><td>is the base address of the device. If address
          translation is being used, then this parameter must reflect the
          virtual base address. Otherwise, the physical address should be
          used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if initialization is successful else XST_FAILURE</dd></dl>
******************************************************************************/
int XV_HdmiRxSs_CfgInitialize(<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *InstancePtr,
    <a class="el" href="struct_x_v___hdmi_rx_ss___config.html" title="Video Processing Subsystem configuration structure. ">XV_HdmiRxSs_Config</a> *CfgPtr,
    UINTPTR EffectiveAddr)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = InstancePtr;</pre><pre>  /* Verify arguments */
  Xil_AssertNonvoid(HdmiRxSsPtr != NULL);
  Xil_AssertNonvoid(CfgPtr != NULL);
  Xil_AssertNonvoid(EffectiveAddr != (UINTPTR)NULL);</pre><pre>  /* Setup the instance */
  memcpy((void *)&amp;(HdmiRxSsPtr-&gt;Config), (const void *)CfgPtr,
    sizeof(XV_HdmiRxSs_Config));
  HdmiRxSsPtr-&gt;Config.BaseAddress = EffectiveAddr;</pre><pre>  /* Determine sub-cores included in the provided instance of subsystem */
  XV_HdmiRxSs_GetIncludedSubcores(HdmiRxSsPtr, CfgPtr-&gt;DeviceId);</pre><pre>  /* Initialize all included sub_cores */
  if(HdmiRxSsPtr-&gt;HdmiRxPtr)
  {
    if(XV_HdmiRxSs_SubcoreInitHdmiRx(HdmiRxSsPtr) != XST_SUCCESS)
    {
      return(XST_FAILURE);
    }
  }</pre><pre>  /* Register Callbacks */
  XV_HdmiRxSs_RegisterSubsysCallbacks(HdmiRxSsPtr);</pre><pre>  /* Reset the hardware and set the flag to indicate the
     subsystem is ready
   */
  XV_HdmiRxSs_Reset(HdmiRxSsPtr);
  HdmiRxSsPtr-&gt;IsReady = XIL_COMPONENT_IS_READY;</pre><pre>  return(XST_SUCCESS);
}</pre><pre>/****************************************************************************/
/**
  This function starts the HDMI RX subsystem including all sub-cores that are
  included in the processing pipeline for a given use-case. Video pipe is
  started from back to front
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Subsystem instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Cores are started only if the corresponding start flag in the scratch
        pad memory is set. This allows to selectively start only those cores
        included in the processing chain
******************************************************************************/
void XV_HdmiRxSs_Start(XV_HdmiRxSs *InstancePtr)
{
  Xil_AssertVoid(InstancePtr != NULL);</dd></dl>
XV_HdmiRxSs_LogWrite(InstancePtr, XV_HDMIRXSS_LOG_EVT_START, 0);</pre><pre>  /* Set RX hot plug detect */
  XV_HdmiRx_SetHpd(InstancePtr-&gt;HdmiRxPtr, TRUE);</pre><pre>  /* Disable Audio Peripheral */
  XV_HdmiRx_AudioDisable(InstancePtr-&gt;HdmiRxPtr);
  XV_HdmiRx_AudioIntrDisable(InstancePtr-&gt;HdmiRxPtr);
}</pre><pre>/*****************************************************************************/
/**
  This function stops the HDMI RX subsystem including all sub-cores
  Stop the video pipe starting from front to back</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Subsystem instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
******************************************************************************/
void XV_HdmiRxSs_Stop(XV_HdmiRxSs *InstancePtr)
{
  Xil_AssertVoid(InstancePtr != NULL);</pre><pre>  XV_HdmiRxSs_LogWrite(InstancePtr, XV_HDMIRXSS_LOG_EVT_STOP, 0);</pre><pre>}</pre><pre>/*****************************************************************************/
/**
  This function resets the video subsystem sub-cores. There are 2 reset
  networks within the subsystem<ul>
<li>For cores that are on AXIS interface</li>
<li>For cores that are on AXI-MM interface</li>
</ul>
</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Subsystem instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
******************************************************************************/
void XV_HdmiRxSs_Reset(XV_HdmiRxSs *InstancePtr)
{
  Xil_AssertVoid(InstancePtr != NULL);</pre><pre>  XV_HdmiRxSs_LogWrite(InstancePtr, XV_HDMIRXSS_LOG_EVT_RESET, 0);</pre><pre>  /* Assert RX reset */
  XV_HdmiRx_Reset(InstancePtr-&gt;HdmiRxPtr, TRUE);</pre><pre>  /* Release RX reset */
  XV_HdmiRx_Reset(InstancePtr-&gt;HdmiRxPtr, FALSE);
}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when a RX connect event has occurred.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_ConnectCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;</pre><pre>  // Is the cable connected?
  if (XV_HdmiRx_IsStreamConnected(HdmiRxSsPtr-&gt;HdmiRxPtr)) {</pre><pre>    XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_CONNECT, 0);</pre><pre>    // Set RX hot plug detect
    XV_HdmiRx_SetHpd(HdmiRxSsPtr-&gt;HdmiRxPtr, TRUE);</pre><pre>    // Set stream connected flag
    HdmiRxSsPtr-&gt;IsStreamConnected = (TRUE);</pre><pre>  }</pre><pre>  // RX cable is disconnected
  else {</pre><pre>    XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_DISCONNECT, 0);</pre><pre>    // Clear RX hot plug detect
    XV_HdmiRx_SetHpd(HdmiRxSsPtr-&gt;HdmiRxPtr, FALSE);</pre><pre>    // Set stream connected flag
    HdmiRxSsPtr-&gt;IsStreamConnected = (FALSE);</pre><pre><pre class="fragment">XV_HdmiRx_SetScrambler(HdmiRxSsPtr-&gt;HdmiRxPtr, (FALSE)); //Disable scrambler
</pre>
  }</pre><pre>  // Check if user callback has been registered
  if (HdmiRxSsPtr-&gt;ConnectCallback) {
    HdmiRxSsPtr-&gt;ConnectCallback(HdmiRxSsPtr-&gt;ConnectRef);
  }</pre><pre>}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when a RX AUX IRQ has occurred.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_AuxCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;</pre><pre>  // Retrieve Vendor Specific Info Frame
  XV_HdmiRxSs_RetrieveVSInfoframe(HdmiRxSsPtr-&gt;HdmiRxPtr);</pre><pre>  // HDMI mode
  if (XV_HdmiRxSs_GetVideoStreamType(HdmiRxSsPtr )) {</pre><pre>  }</pre><pre>  // Check if user callback has been registered
  if (HdmiRxSsPtr-&gt;AuxCallback) {
      HdmiRxSsPtr-&gt;AuxCallback(HdmiRxSsPtr-&gt;AuxRef);
  }
}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when a RX Sync Loss IRQ has occurred.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_SyncLossCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;</pre><pre>  // Push sync loss event to HDCP event queue</pre><pre>  XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_SYNCLOSS, 0);</pre><pre>}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when the mode has transitioned from DVI to HDMI or
  vice versa.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_ModeCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;</pre><pre>  // HDMI mode
  if (XV_HdmiRxSs_GetVideoStreamType(HdmiRxSsPtr )) {</pre><pre>    XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_HDMIMODE, 0);</pre><pre>  }</pre><pre>  // DVI mode
  else {</pre><pre>    XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_DVIMODE, 0);</pre><pre>  }
}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function retrieves the Vendor Specific Info Frame.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_RetrieveVSInfoframe(XV_HdmiRx *HdmiRx)
{
  /** Vendor-Specific InfoFrame structure */
  XV_HdmiRx_VSIF VSIF;</pre><pre>  if (HdmiRx-&gt;Aux.Header.Byte[0] == 0x81) {
      XV_HdmiRx_VSIF_ParsePacket(&amp;HdmiRx-&gt;Aux, &amp;VSIF);</pre><pre>      // Defaults
      HdmiRx-&gt;Stream.Video.Is3D = FALSE;
      HdmiRx-&gt;Stream.Video.Info_3D.Format = XVIDC_3D_UNKNOWN;</pre><pre>      if (VSIF.Format == XV_HDMIRX_VSIF_VF_3D) {
          HdmiRx-&gt;Stream.Video.Is3D = TRUE;
          HdmiRx-&gt;Stream.Video.Info_3D = VSIF.Info_3D.Stream;
      } else if (VSIF.Format == XV_HDMIRX_VSIF_VF_EXTRES) {
          switch(VSIF.HDMI_VIC) {
              case 1 :
                  HdmiRx-&gt;Stream.Vic = 95;
                  break;</pre><pre>              case 2 :
                  HdmiRx-&gt;Stream.Vic = 94;
                  break;</pre><pre>              case 3 :
                  HdmiRx-&gt;Stream.Vic = 93;
                  break;</pre><pre>              case 4 :
                  HdmiRx-&gt;Stream.Vic = 98;
                  break;</pre><pre>              default :
                  break;
          }
      }
  }
}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when a RX Audio IRQ has occurred.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_AudCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;</pre><pre>  u8 Channels;</pre><pre>  if (XV_HdmiRx_IsAudioActive(HdmiRxSsPtr-&gt;HdmiRxPtr)) {</pre><pre>    // Get audio channels
    Channels = XV_HdmiRx_GetAudioChannels(HdmiRxSsPtr-&gt;HdmiRxPtr);
    HdmiRxSsPtr-&gt;AudioChannels = Channels;
  }</pre><pre>  // Check if user callback has been registered
  if (HdmiRxSsPtr-&gt;AudCallback) {
      HdmiRxSsPtr-&gt;AudCallback(HdmiRxSsPtr-&gt;AudRef);
  }
}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when a RX Link Status IRQ has occurred.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_LnkStaCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;</pre><pre>  HdmiRxSsPtr-&gt;IsLinkStatusErrMax =
    XV_HdmiRx_IsLinkStatusErrMax(HdmiRxSsPtr-&gt;HdmiRxPtr);</pre><pre>  XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_LINKSTATUS, 0);</pre><pre>  // Check if user callback has been registered
  if (HdmiRxSsPtr-&gt;LnkStaCallback) {
      HdmiRxSsPtr-&gt;LnkStaCallback(HdmiRxSsPtr-&gt;LnkStaRef);
  }
}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when a RX DDC IRQ has occurred.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_DdcCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;</pre><pre>  // Check if user callback has been registered
  if (HdmiRxSsPtr-&gt;DdcCallback) {
      HdmiRxSsPtr-&gt;DdcCallback(HdmiRxSsPtr-&gt;DdcRef);
  }
}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when the RX stream is down.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_StreamDownCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;</pre><pre>  // Assert HDMI RX reset
  XV_HdmiRx_Reset(HdmiRxSsPtr-&gt;HdmiRxPtr, TRUE);</pre><pre>  /* Set stream up flag */
  HdmiRxSsPtr-&gt;IsStreamUp = (FALSE);</pre><pre>  XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_STREAMDOWN, 0);</pre><pre>  // Check if user callback has been registered
  if (HdmiRxSsPtr-&gt;StreamDownCallback) {
      HdmiRxSsPtr-&gt;StreamDownCallback(HdmiRxSsPtr-&gt;StreamDownRef);
  }</pre><pre>}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when the RX stream init .</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_StreamInitCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;</pre><pre>  XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_STREAMINIT, 0);</pre><pre>  // Check if user callback has been registered
  if (HdmiRxSsPtr-&gt;StreamInitCallback) {
      HdmiRxSsPtr-&gt;StreamInitCallback(HdmiRxSsPtr-&gt;StreamInitRef);
  }</pre><pre>}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when the RX stream is up.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_StreamUpCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;</pre><pre>  /* Clear link Status error counters */
  XV_HdmiRx_ClearLinkStatus(HdmiRxSsPtr-&gt;HdmiRxPtr);</pre><pre>  /* Set stream up flag */
  HdmiRxSsPtr-&gt;IsStreamUp = (TRUE);</pre><pre>  XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_STREAMUP, 0);</pre><pre>  /* Configure Remapper according to HW setting and video format */
  XV_HdmiRxSs_ConfigBridgeMode(HdmiRxSsPtr);</pre><pre>  // Check if user callback has been registered
  if (HdmiRxSsPtr-&gt;StreamUpCallback) {
      HdmiRxSsPtr-&gt;StreamUpCallback(HdmiRxSsPtr-&gt;StreamUpRef);
  }</pre><pre>}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function installs an asynchronous callback function for the given
  HandlerType:</pre><pre>  <pre>
  HandlerType                     Callback Function Type
  -----------------------         --------------------------------------------------
  (XV_HDMIRXSS_HANDLER_CONNECT)             HpdCallback
  (XV_HDMIRXSS_HANDLER_VS)                  VsCallback
  (XV_HDMIRXSS_HANDLER_STREAM_DOWN)         StreamDownCallback
  (XV_HDMIRXSS_HANDLER_STREAM_UP)           StreamUpCallback
  (XV_HDMIRXSS_HANDLER_HDCP_AUTHENTICATED)
  (XV_HDMIRXSS_HANDLER_HDCP_UNAUTHENTICATED)
  (XV_HDMIRXSS_HANDLER_HDCP_AUTHENTICATION_REQUEST)
  (XV_HDMIRXSS_HANDLER_HDCP_STREAM_MANAGE_REQUEST)
  (XV_HDMIRXSS_HANDLER_HDCP_TOPOLOGY_UPDATE)
  </pre></pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the HDMI RX Subsystem instance.
</td></tr>
    <tr><td class="paramname">HandlerType</td><td>specifies the type of handler.
</td></tr>
    <tr><td class="paramname">CallbackFunc</td><td>is the address of the callback function.
</td></tr>
    <tr><td class="paramname">CallbackRef</td><td>is a user data item that will be passed to the
        callback function when it is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if callback function installed successfully.</li>
<li>XST_INVALID_PARAM when HandlerType is invalid.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Invoking this function for a handler that already has been
        installed replaces it with the new handler.
</dd></dl>
</pre></div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a277acac840c40692bcc133be2137a6e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a277acac840c40692bcc133be2137a6e6">XV_HdmiRxSs_SetEdidParam</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, u8 *EdidDataPtr, u16 Length)</td></tr>
<tr class="memdesc:a277acac840c40692bcc133be2137a6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function Sets the EDID parameters in the HDMI RX SS struct.  <a href="#a277acac840c40692bcc133be2137a6e6">More...</a><br /></td></tr>
<tr class="separator:a277acac840c40692bcc133be2137a6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158d8801dd2e574b12230ad44a1bf662"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a158d8801dd2e574b12230ad44a1bf662">XV_HdmiRxSs_LoadDefaultEdid</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:a158d8801dd2e574b12230ad44a1bf662"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads the default EDID to the HDMI RX.  <a href="#a158d8801dd2e574b12230ad44a1bf662">More...</a><br /></td></tr>
<tr class="separator:a158d8801dd2e574b12230ad44a1bf662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd3689aa607f944f9eea1db1d37a2f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#abfd3689aa607f944f9eea1db1d37a2f3">XV_HdmiRxSs_LoadEdid</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, u8 *EdidDataPtr, u16 Length)</td></tr>
<tr class="memdesc:abfd3689aa607f944f9eea1db1d37a2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads the default EDID to the HDMI RX.  <a href="#abfd3689aa607f944f9eea1db1d37a2f3">More...</a><br /></td></tr>
<tr class="separator:abfd3689aa607f944f9eea1db1d37a2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f531fa69066bf7cf1491d98b5a16e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a08f531fa69066bf7cf1491d98b5a16e0">XV_HdmiRxSs_SetHpd</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, u8 Value)</td></tr>
<tr class="memdesc:a08f531fa69066bf7cf1491d98b5a16e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the HPD on the HDMI RX.  <a href="#a08f531fa69066bf7cf1491d98b5a16e0">More...</a><br /></td></tr>
<tr class="separator:a08f531fa69066bf7cf1491d98b5a16e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938e999c689d01ff3559e472f21c9757"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a938e999c689d01ff3559e472f21c9757">XV_HdmiRxSs_ToggleHpd</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:a938e999c689d01ff3559e472f21c9757"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function toggles the HPD on the HDMI RX.  <a href="#a938e999c689d01ff3559e472f21c9757">More...</a><br /></td></tr>
<tr class="separator:a938e999c689d01ff3559e472f21c9757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc5756e7c68a5abc93dc6fcb562db03"><td class="memItemLeft" align="right" valign="top">XV_HdmiRx_Aux *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#abdc5756e7c68a5abc93dc6fcb562db03">XV_HdmiRxSs_GetAuxiliary</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:abdc5756e7c68a5abc93dc6fcb562db03"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the pointer to HDMI RX SS Aux structure.  <a href="#abdc5756e7c68a5abc93dc6fcb562db03">More...</a><br /></td></tr>
<tr class="separator:abdc5756e7c68a5abc93dc6fcb562db03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6156f804fb138799bb3bd9a243dd36cf"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a6156f804fb138799bb3bd9a243dd36cf">XV_HdmiRxSs_SetStream</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, u32 Clock, u32 LineRate)</td></tr>
<tr class="memdesc:a6156f804fb138799bb3bd9a243dd36cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function set HDMI RX susbsystem stream parameters.  <a href="#a6156f804fb138799bb3bd9a243dd36cf">More...</a><br /></td></tr>
<tr class="separator:a6156f804fb138799bb3bd9a243dd36cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4f848d7fbcea5843ae8bab4d255e2e"><td class="memItemLeft" align="right" valign="top">XVidC_VideoStream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#acf4f848d7fbcea5843ae8bab4d255e2e">XV_HdmiRxSs_GetVideoStream</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:acf4f848d7fbcea5843ae8bab4d255e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the pointer to HDMI RX SS video stream.  <a href="#acf4f848d7fbcea5843ae8bab4d255e2e">More...</a><br /></td></tr>
<tr class="separator:acf4f848d7fbcea5843ae8bab4d255e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd6f120b55c78fc21385878b3b930fe"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a3dd6f120b55c78fc21385878b3b930fe">XV_HdmiRxSs_GetVideoIDCode</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:a3dd6f120b55c78fc21385878b3b930fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the pointer to HDMI RX SS video Identification code.  <a href="#a3dd6f120b55c78fc21385878b3b930fe">More...</a><br /></td></tr>
<tr class="separator:a3dd6f120b55c78fc21385878b3b930fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aabf114a6d9281ca99d9128a3932cdc"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a9aabf114a6d9281ca99d9128a3932cdc">XV_HdmiRxSs_GetVideoStreamType</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:a9aabf114a6d9281ca99d9128a3932cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the pointer to HDMI RX SS video stream type.  <a href="#a9aabf114a6d9281ca99d9128a3932cdc">More...</a><br /></td></tr>
<tr class="separator:a9aabf114a6d9281ca99d9128a3932cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a85190f1a8a689e520e612dd2d57d8"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#ab8a85190f1a8a689e520e612dd2d57d8">XV_HdmiRxSs_GetVideoStreamScramblingFlag</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:ab8a85190f1a8a689e520e612dd2d57d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the pointer to HDMI RX SS video stream type.  <a href="#ab8a85190f1a8a689e520e612dd2d57d8">More...</a><br /></td></tr>
<tr class="separator:ab8a85190f1a8a689e520e612dd2d57d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9800e58c46167ce458da016451f88c8d"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a9800e58c46167ce458da016451f88c8d">XV_HdmiRxSs_GetAudioChannels</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:a9800e58c46167ce458da016451f88c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the HDMI RX SS number of active audio channels.  <a href="#a9800e58c46167ce458da016451f88c8d">More...</a><br /></td></tr>
<tr class="separator:a9800e58c46167ce458da016451f88c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc056437ab2bb79bc929f7791db5f95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#abdc056437ab2bb79bc929f7791db5f95">XV_HdmiRxSs_RefClockChangeInit</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:abdc056437ab2bb79bc929f7791db5f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called when HDMI RX SS TMDS clock changes.  <a href="#abdc056437ab2bb79bc929f7791db5f95">More...</a><br /></td></tr>
<tr class="separator:abdc056437ab2bb79bc929f7791db5f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab984feecc99028c5ab95d99e7087e329"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#ab984feecc99028c5ab95d99e7087e329">XV_HdmiRxSs_ReportSubcoreVersion</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:ab984feecc99028c5ab95d99e7087e329"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prints the HDMI RX SS subcore versions.  <a href="#ab984feecc99028c5ab95d99e7087e329">More...</a><br /></td></tr>
<tr class="separator:ab984feecc99028c5ab95d99e7087e329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b31675082ff4bc8968c3f4ab5acff4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a0b31675082ff4bc8968c3f4ab5acff4a">XV_HdmiRxSs_IsStreamUp</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:a0b31675082ff4bc8968c3f4ab5acff4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the video stream is up.  <a href="#a0b31675082ff4bc8968c3f4ab5acff4a">More...</a><br /></td></tr>
<tr class="separator:a0b31675082ff4bc8968c3f4ab5acff4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37eb5417ad17c232be0b46588069a330"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a37eb5417ad17c232be0b46588069a330">XV_HdmiRxSs_IsStreamConnected</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:a37eb5417ad17c232be0b46588069a330"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the interface is connected.  <a href="#a37eb5417ad17c232be0b46588069a330">More...</a><br /></td></tr>
<tr class="separator:a37eb5417ad17c232be0b46588069a330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b6769e137d23ae6a4fe0d61864f5cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a93b6769e137d23ae6a4fe0d61864f5cd">XV_HdmiRxSs_SetDefaultPpc</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, u8 Id)</td></tr>
<tr class="memdesc:a93b6769e137d23ae6a4fe0d61864f5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set the default in HDF.  <a href="#a93b6769e137d23ae6a4fe0d61864f5cd">More...</a><br /></td></tr>
<tr class="separator:a93b6769e137d23ae6a4fe0d61864f5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7296f98d74b618438a08c0bb4d303350"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a7296f98d74b618438a08c0bb4d303350">XV_HdmiRxSs_SetPpc</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, u8 Id, u8 Ppc)</td></tr>
<tr class="memdesc:a7296f98d74b618438a08c0bb4d303350"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set PPC specified by user.  <a href="#a7296f98d74b618438a08c0bb4d303350">More...</a><br /></td></tr>
<tr class="separator:a7296f98d74b618438a08c0bb4d303350"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9800e58c46167ce458da016451f88c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9800e58c46167ce458da016451f88c8d">&#9670;&nbsp;</a></span>XV_HdmiRxSs_GetAudioChannels()</h2>

>>>>>>> upstream/master
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XV_HdmiRxSs_GetAudioChannels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the HDMI RX SS number of active audio channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Channels</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<<<<<<< HEAD
<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a51cc4ea97fa0b2aa6987cd0ef7e8d58a">XV_HdmiRxSs::AudioChannels</a>.</p>

</div>
</div>
<a class="anchor" id="abdc5756e7c68a5abc93dc6fcb562db03"></a>
=======
<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a51cc4ea97fa0b2aa6987cd0ef7e8d58a">XV_HdmiRxSs::AudioChannels</a>.</p>

</div>
</div>
<a id="abdc5756e7c68a5abc93dc6fcb562db03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc5756e7c68a5abc93dc6fcb562db03">&#9670;&nbsp;</a></span>XV_HdmiRxSs_GetAuxiliary()</h2>

>>>>>>> upstream/master
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XV_HdmiRx_Aux* XV_HdmiRxSs_GetAuxiliary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the pointer to HDMI RX SS Aux structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XVidC_VideoStream pointer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<<<<<<< HEAD
<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a class="anchor" id="a3dd6f120b55c78fc21385878b3b930fe"></a>
=======
<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a id="a3dd6f120b55c78fc21385878b3b930fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd6f120b55c78fc21385878b3b930fe">&#9670;&nbsp;</a></span>XV_HdmiRxSs_GetVideoIDCode()</h2>

>>>>>>> upstream/master
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XV_HdmiRxSs_GetVideoIDCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the pointer to HDMI RX SS video Identification code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VIC</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<<<<<<< HEAD
<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a class="anchor" id="acf4f848d7fbcea5843ae8bab4d255e2e"></a>
=======
<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a id="acf4f848d7fbcea5843ae8bab4d255e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4f848d7fbcea5843ae8bab4d255e2e">&#9670;&nbsp;</a></span>XV_HdmiRxSs_GetVideoStream()</h2>

>>>>>>> upstream/master
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XVidC_VideoStream* XV_HdmiRxSs_GetVideoStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the pointer to HDMI RX SS video stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XVidC_VideoStream pointer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<<<<<<< HEAD
<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

<p>Referenced by <a class="el" href="xv__hdmirxss_8h.html#a37eb5417ad17c232be0b46588069a330">XV_HdmiRxSs_IsStreamConnected()</a>.</p>

</div>
</div>
<a class="anchor" id="ab8a85190f1a8a689e520e612dd2d57d8"></a>
=======
<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a id="ab8a85190f1a8a689e520e612dd2d57d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a85190f1a8a689e520e612dd2d57d8">&#9670;&nbsp;</a></span>XV_HdmiRxSs_GetVideoStreamScramblingFlag()</h2>

>>>>>>> upstream/master
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XV_HdmiRxSs_GetVideoStreamScramblingFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the pointer to HDMI RX SS video stream type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stream Type 1:IsScrambled 0: not Scrambled</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<<<<<<< HEAD
<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a class="anchor" id="a9aabf114a6d9281ca99d9128a3932cdc"></a>
=======
<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a id="a9aabf114a6d9281ca99d9128a3932cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aabf114a6d9281ca99d9128a3932cdc">&#9670;&nbsp;</a></span>XV_HdmiRxSs_GetVideoStreamType()</h2>

>>>>>>> upstream/master
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XV_HdmiRxSs_GetVideoStreamType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the pointer to HDMI RX SS video stream type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stream Type 1:HDMI 0:DVI</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<<<<<<< HEAD
<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a class="anchor" id="a187813c9c9aa0bc87fda96af6b4b98e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSS_HdmiRxIntrHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calls the interrupt handler for HDMI RX. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the HDMI RX Subsystem </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#af4a869965ee18d575d19b4319be08ff0">XV_HdmiRxSs::Config</a>, <a class="el" href="struct_x_v___hdmi_rx_ss___config.html#ac2fbb1bb237fb962318fd3e6512abdb2">XV_HdmiRxSs_Config::Hdcp14</a>, <a class="el" href="struct_x_v___hdmi_rx_ss___config.html#a5c83dac27c643fce4f90a5a082c1f3d8">XV_HdmiRxSs_Config::Hdcp22</a>, <a class="el" href="struct_x_v___hdmi_rx_ss___config.html#a2059d6ab17d86b73b79a6d45928a2dfc">XV_HdmiRxSs_Config::HdcpTimer</a>, <a class="el" href="struct_x_v___hdmi_rx_ss___config.html#ad08f9bc0025dc447f1d91d62e03d6c89">XV_HdmiRxSs_Config::HdmiRx</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>, <a class="el" href="struct_x_v___hdmi_rx_ss___sub_core.html#add5315499fc23113e5f471ab8cac5079">XV_HdmiRxSs_SubCore::IsPresent</a>, <a class="el" href="struct_x_v___hdmi_rx_ss___config.html#a74e4f03873c0df1e5a7c2a72ab457c70">XV_HdmiRxSs_Config::Remapper</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a72aed4475f1e790c8de8526be0c2cb1d">XV_HdmiRxSs::RemapperPtr</a>, <a class="el" href="struct_x_v___hdmi_rx_ss___config.html#a11cc6236b64f53541a70fb7568b052d0">XV_HdmiRxSs_Config::RemapperReset</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#adda5a89c1c0b0982984e60fe8f2e9113">XV_HdmiRxSs::RemapperResetPtr</a>, and <a class="el" href="xv__hdmirxss_8c.html#a39a18defddd74705ecd2b99d651db86c">XV_HdmiRxSs_SubCoreRepo</a>.</p>

</div>
</div>
<a class="anchor" id="a37eb5417ad17c232be0b46588069a330"></a>
=======
<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a id="a37eb5417ad17c232be0b46588069a330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37eb5417ad17c232be0b46588069a330">&#9670;&nbsp;</a></span>XV_HdmiRxSs_IsStreamConnected()</h2>

>>>>>>> upstream/master
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XV_HdmiRxSs_IsStreamConnected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if the interface is connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE if interface is connected.</li>
<li>FALSE if interface is not connected.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<<<<<<< HEAD
<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#aec331a506d29a1b33d817ef68c2ad429">XV_HdmiRxSs::IsStreamConnected</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a72aed4475f1e790c8de8526be0c2cb1d">XV_HdmiRxSs::RemapperPtr</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#adda5a89c1c0b0982984e60fe8f2e9113">XV_HdmiRxSs::RemapperResetPtr</a>, and <a class="el" href="xv__hdmirxss_8c.html#acf4f848d7fbcea5843ae8bab4d255e2e">XV_HdmiRxSs_GetVideoStream()</a>.</p>

</div>
</div>
<a class="anchor" id="a0b31675082ff4bc8968c3f4ab5acff4a"></a>
=======
<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#aec331a506d29a1b33d817ef68c2ad429">XV_HdmiRxSs::IsStreamConnected</a>.</p>

</div>
</div>
<a id="a0b31675082ff4bc8968c3f4ab5acff4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b31675082ff4bc8968c3f4ab5acff4a">&#9670;&nbsp;</a></span>XV_HdmiRxSs_IsStreamUp()</h2>

>>>>>>> upstream/master
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XV_HdmiRxSs_IsStreamUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if the video stream is up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE if stream is up.</li>
<li>FALSE if stream is down.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<<<<<<< HEAD
<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a56f7512abbb2a096ac259d40132f4628">XV_HdmiRxSs::IsStreamUp</a>.</p>

</div>
</div>
<a class="anchor" id="a158d8801dd2e574b12230ad44a1bf662"></a>
=======
<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a56f7512abbb2a096ac259d40132f4628">XV_HdmiRxSs::IsStreamUp</a>.</p>

</div>
</div>
<a id="a158d8801dd2e574b12230ad44a1bf662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158d8801dd2e574b12230ad44a1bf662">&#9670;&nbsp;</a></span>XV_HdmiRxSs_LoadDefaultEdid()</h2>

>>>>>>> upstream/master
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSs_LoadDefaultEdid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function loads the default EDID to the HDMI RX. </p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<<<<<<< HEAD
<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a0275583454eea8db5b073368ae009905">XV_HdmiRxSs::EdidLength</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a2ec65acd67fc707df2287d473f107814">XV_HdmiRxSs::EdidPtr</a>, and <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a class="anchor" id="abfd3689aa607f944f9eea1db1d37a2f3"></a>
=======
<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a0275583454eea8db5b073368ae009905">XV_HdmiRxSs::EdidLength</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a2ec65acd67fc707df2287d473f107814">XV_HdmiRxSs::EdidPtr</a>, and <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a id="abfd3689aa607f944f9eea1db1d37a2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd3689aa607f944f9eea1db1d37a2f3">&#9670;&nbsp;</a></span>XV_HdmiRxSs_LoadEdid()</h2>

>>>>>>> upstream/master
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSs_LoadEdid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>EdidDataPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function loads the default EDID to the HDMI RX. </p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<<<<<<< HEAD
<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a class="anchor" id="abdc056437ab2bb79bc929f7791db5f95"></a>
=======
<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a id="abdc056437ab2bb79bc929f7791db5f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc056437ab2bb79bc929f7791db5f95">&#9670;&nbsp;</a></span>XV_HdmiRxSs_RefClockChangeInit()</h2>

>>>>>>> upstream/master
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSs_RefClockChangeInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called when HDMI RX SS TMDS clock changes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<<<<<<< HEAD
<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#aaccf9db2828b2d0ee5f6e05e80665a9d">XV_HdmiRxSs::TMDSClockRatio</a>, <a class="el" href="xv__hdmirxss_8h.html#a801bb980bfbb34a0663bbe062e040a15a9703ad76bc27e43a049a13ee81dc235a">XV_HDMIRXSS_LOG_EVT_REFCLOCKCHANGE</a>, and <a class="el" href="xv__hdmirxss_8h.html#a56c28560c5de8682b22f96d40fa4e24d">XV_HdmiRxSs_LogWrite()</a>.</p>

</div>
</div>
<a class="anchor" id="ad9f6e6e2ae968974f36910a74ede0e2f"></a>
=======
<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#aaccf9db2828b2d0ee5f6e05e80665a9d">XV_HdmiRxSs::TMDSClockRatio</a>, <a class="el" href="xv__hdmirxss_8h.html#a801bb980bfbb34a0663bbe062e040a15a9703ad76bc27e43a049a13ee81dc235a">XV_HDMIRXSS_LOG_EVT_REFCLOCKCHANGE</a>, and <a class="el" href="xv__hdmirxss_8h.html#a56c28560c5de8682b22f96d40fa4e24d">XV_HdmiRxSs_LogWrite()</a>.</p>

</div>
</div>
<a id="ab984feecc99028c5ab95d99e7087e329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab984feecc99028c5ab95d99e7087e329">&#9670;&nbsp;</a></span>XV_HdmiRxSs_ReportSubcoreVersion()</h2>

>>>>>>> upstream/master
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
<<<<<<< HEAD
          <td class="memname">void XV_HdmiRxSs_Reset </td>
=======
          <td class="memname">void XV_HdmiRxSs_ReportSubcoreVersion </td>
>>>>>>> upstream/master
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<<<<<<< HEAD
<p>This function resets the video subsystem sub-cores. </p>
<p>There are 2 reset networks within the subsystem</p><ul>
<li>For cores that are on AXIS interface</li>
<li>For cores that are on AXI-MM interface</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Subsystem instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a8835d6d3df6f5280ddc1bdb6b439feb9">XV_HdmiRxSs::AudCallback</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a51cc4ea97fa0b2aa6987cd0ef7e8d58a">XV_HdmiRxSs::AudioChannels</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a88d76a11fb8a3a0fe46760ca1a6b2bf4">XV_HdmiRxSs::AudRef</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a7a3c8c5d7742bce47f4480a769576bcf">XV_HdmiRxSs::AuxCallback</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#aa9ddc0b270ab97f23a3571f222e8b223">XV_HdmiRxSs::AuxRef</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a607ecc1cf94b1a143c5580859258002a">XV_HdmiRxSs::ConnectCallback</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a121af8d5c9a351689839a2f5d4b73592">XV_HdmiRxSs::ConnectRef</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a720eb294b6a7aa42f309a27c14cc947e">XV_HdmiRxSs::DdcCallback</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3290358f27fc766ce8682392348d9c71">XV_HdmiRxSs::DdcRef</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a7898bb71c92abac224b926e4b5ee01b8">XV_HdmiRxSs::IsLinkStatusErrMax</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#aec331a506d29a1b33d817ef68c2ad429">XV_HdmiRxSs::IsStreamConnected</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a56f7512abbb2a096ac259d40132f4628">XV_HdmiRxSs::IsStreamUp</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a53eb52bc6933b67edad6bcf0301cc67c">XV_HdmiRxSs::LnkStaCallback</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#afbc89b1043cefced982c32a14d511fbb">XV_HdmiRxSs::LnkStaRef</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a72aed4475f1e790c8de8526be0c2cb1d">XV_HdmiRxSs::RemapperPtr</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#adda5a89c1c0b0982984e60fe8f2e9113">XV_HdmiRxSs::RemapperResetPtr</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a77913cb46aa7408e4c34dff859477723">XV_HdmiRxSs::StreamDownCallback</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a178d7591ff45f38f06702109f980f5a1">XV_HdmiRxSs::StreamDownRef</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a8e6fb1b63ddeab39f8268a32edb970e5">XV_HdmiRxSs::StreamInitCallback</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a8ee1e45506bb23876a272c913dae7053">XV_HdmiRxSs::StreamInitRef</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#ae6f6eddc32a4d8473cea90fc2aaf9d6e">XV_HdmiRxSs::StreamUpCallback</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a517bfdc93369c91bdcf5f562856af304">XV_HdmiRxSs::StreamUpRef</a>, <a class="el" href="xv__hdmirxss_8c.html#a1362a48baa691bf7a4d0f174cc699b62">VSIF</a>, <a class="el" href="xv__hdmirxss_8h.html#a801bb980bfbb34a0663bbe062e040a15a9eb981306ed098ffff9be38ab01c1517">XV_HDMIRXSS_LOG_EVT_CONNECT</a>, <a class="el" href="xv__hdmirxss_8h.html#a801bb980bfbb34a0663bbe062e040a15a5f135a325a55a42537d1fe42a7305aad">XV_HDMIRXSS_LOG_EVT_DISCONNECT</a>, <a class="el" href="xv__hdmirxss_8h.html#a801bb980bfbb34a0663bbe062e040a15aee12765ad4c6a164b7368fadf1123c3a">XV_HDMIRXSS_LOG_EVT_LINKSTATUS</a>, <a class="el" href="xv__hdmirxss_8h.html#a801bb980bfbb34a0663bbe062e040a15ab484e1c8a94a2b261abda95ff93179e9">XV_HDMIRXSS_LOG_EVT_RESET</a>, <a class="el" href="xv__hdmirxss_8h.html#a801bb980bfbb34a0663bbe062e040a15ac7a34ea100510d48389285150eac34ab">XV_HDMIRXSS_LOG_EVT_STREAMDOWN</a>, <a class="el" href="xv__hdmirxss_8h.html#a801bb980bfbb34a0663bbe062e040a15a72f5c5220a5d12997ce99ba12b319e48">XV_HDMIRXSS_LOG_EVT_STREAMINIT</a>, <a class="el" href="xv__hdmirxss_8h.html#a801bb980bfbb34a0663bbe062e040a15a88abfe8933839190302c4ef9f2c3b4b2">XV_HDMIRXSS_LOG_EVT_STREAMUP</a>, and <a class="el" href="xv__hdmirxss_8h.html#a56c28560c5de8682b22f96d40fa4e24d">XV_HdmiRxSs_LogWrite()</a>.</p>

<p>Referenced by <a class="el" href="xv__hdmirxss_8h.html#aaf2419b376d0b737a59d86da1ef67bcf">XV_HdmiRxSs_CfgInitialize()</a>.</p>

</div>
</div>
<a class="anchor" id="aa2c1cbe31410b05b71e999b585a89e8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XV_HdmiRxSs_SetCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>HandlerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallbackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function installs an asynchronous callback function for the given HandlerType: </p>
<pre>
HandlerType                     Callback Function Type
-----------------------         --------------------------------------------------
(XV_HDMIRXSS_HANDLER_CONNECT)             HpdCallback
(XV_HDMIRXSS_HANDLER_VS)                  VsCallback
(XV_HDMIRXSS_HANDLER_STREAM_DOWN)         StreamDownCallback
(XV_HDMIRXSS_HANDLER_STREAM_UP)           StreamUpCallback
(XV_HDMIRXSS_HANDLER_HDCP_AUTHENTICATED)
(XV_HDMIRXSS_HANDLER_HDCP_UNAUTHENTICATED)
(XV_HDMIRXSS_HANDLER_HDCP_AUTHENTICATION_REQUEST)
(XV_HDMIRXSS_HANDLER_HDCP_STREAM_MANAGE_REQUEST)
(XV_HDMIRXSS_HANDLER_HDCP_TOPOLOGY_UPDATE)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the HDMI RX Subsystem instance. </td></tr>
    <tr><td class="paramname">HandlerType</td><td>specifies the type of handler. </td></tr>
    <tr><td class="paramname">CallbackFunc</td><td>is the address of the callback function. </td></tr>
    <tr><td class="paramname">CallbackRef</td><td>is a user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if callback function installed successfully.</li>
<li>XST_INVALID_PARAM when HandlerType is invalid.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Invoking this function for a handler that already has been installed replaces it with the new handler. </dd></dl>

<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a8835d6d3df6f5280ddc1bdb6b439feb9">XV_HdmiRxSs::AudCallback</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a88d76a11fb8a3a0fe46760ca1a6b2bf4">XV_HdmiRxSs::AudRef</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a7a3c8c5d7742bce47f4480a769576bcf">XV_HdmiRxSs::AuxCallback</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#aa9ddc0b270ab97f23a3571f222e8b223">XV_HdmiRxSs::AuxRef</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a607ecc1cf94b1a143c5580859258002a">XV_HdmiRxSs::ConnectCallback</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a121af8d5c9a351689839a2f5d4b73592">XV_HdmiRxSs::ConnectRef</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a720eb294b6a7aa42f309a27c14cc947e">XV_HdmiRxSs::DdcCallback</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3290358f27fc766ce8682392348d9c71">XV_HdmiRxSs::DdcRef</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#adb6017f6d6aaf007ff2b3bc595b28a95">XV_HdmiRxSs::HdcpCallback</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3fe9b79569053a35c3de4c81b974d41d">XV_HdmiRxSs::HdcpRef</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a53eb52bc6933b67edad6bcf0301cc67c">XV_HdmiRxSs::LnkStaCallback</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#afbc89b1043cefced982c32a14d511fbb">XV_HdmiRxSs::LnkStaRef</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a77913cb46aa7408e4c34dff859477723">XV_HdmiRxSs::StreamDownCallback</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a178d7591ff45f38f06702109f980f5a1">XV_HdmiRxSs::StreamDownRef</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a8e6fb1b63ddeab39f8268a32edb970e5">XV_HdmiRxSs::StreamInitCallback</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a8ee1e45506bb23876a272c913dae7053">XV_HdmiRxSs::StreamInitRef</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#ae6f6eddc32a4d8473cea90fc2aaf9d6e">XV_HdmiRxSs::StreamUpCallback</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a517bfdc93369c91bdcf5f562856af304">XV_HdmiRxSs::StreamUpRef</a>, <a class="el" href="xv__hdmirxss_8h.html#a0a9c3372906c60e8125731f9753d4bdca462cd409aedf103cce8372a50df39120">XV_HDMIRXSS_HANDLER_AUD</a>, <a class="el" href="xv__hdmirxss_8h.html#a0a9c3372906c60e8125731f9753d4bdca57d7bf01bae73e5cd80d5d42607b671f">XV_HDMIRXSS_HANDLER_AUX</a>, <a class="el" href="xv__hdmirxss_8h.html#a0a9c3372906c60e8125731f9753d4bdca98676f6fea09b0a63356afddfa8b2dcc">XV_HDMIRXSS_HANDLER_CONNECT</a>, <a class="el" href="xv__hdmirxss_8h.html#a0a9c3372906c60e8125731f9753d4bdca0191d938e161eedd9fe236363ac3751d">XV_HDMIRXSS_HANDLER_DDC</a>, <a class="el" href="xv__hdmirxss_8h.html#a0a9c3372906c60e8125731f9753d4bdca6a3fdbe7918a47206068403cb548071d">XV_HDMIRXSS_HANDLER_HDCP</a>, <a class="el" href="xv__hdmirxss_8h.html#a0a9c3372906c60e8125731f9753d4bdca39942893f580f21e32a68ccbfd0a8be2">XV_HDMIRXSS_HANDLER_HDCP_AUTHENTICATED</a>, <a class="el" href="xv__hdmirxss_8h.html#a0a9c3372906c60e8125731f9753d4bdca2d48f41d950509ae150f468a4e4f53de">XV_HDMIRXSS_HANDLER_HDCP_AUTHENTICATION_REQUEST</a>, <a class="el" href="xv__hdmirxss_8h.html#a0a9c3372906c60e8125731f9753d4bdca4296543c68b257e88bed08c9613c9db3">XV_HDMIRXSS_HANDLER_HDCP_ENCRYPTION_UPDATE</a>, <a class="el" href="xv__hdmirxss_8h.html#a0a9c3372906c60e8125731f9753d4bdca3d2a7adebe7dc6a7bfa77df401c66011">XV_HDMIRXSS_HANDLER_HDCP_STREAM_MANAGE_REQUEST</a>, <a class="el" href="xv__hdmirxss_8h.html#a0a9c3372906c60e8125731f9753d4bdca8e3b76e177cee74843e7fd0ba83eac11">XV_HDMIRXSS_HANDLER_HDCP_TOPOLOGY_UPDATE</a>, <a class="el" href="xv__hdmirxss_8h.html#a0a9c3372906c60e8125731f9753d4bdca7fe3b0e1271bc55d9569a073e2be5aad">XV_HDMIRXSS_HANDLER_HDCP_UNAUTHENTICATED</a>, <a class="el" href="xv__hdmirxss_8h.html#a0a9c3372906c60e8125731f9753d4bdcada3b93353e6b40e201cadfb1184e8292">XV_HDMIRXSS_HANDLER_LNKSTA</a>, <a class="el" href="xv__hdmirxss_8h.html#a0a9c3372906c60e8125731f9753d4bdcaf330db3728c1acc7140593b840658996">XV_HDMIRXSS_HANDLER_STREAM_DOWN</a>, <a class="el" href="xv__hdmirxss_8h.html#a0a9c3372906c60e8125731f9753d4bdcae778149cfc9504c6caeeb937f73f35f7">XV_HDMIRXSS_HANDLER_STREAM_INIT</a>, and <a class="el" href="xv__hdmirxss_8h.html#a0a9c3372906c60e8125731f9753d4bdcae5f0ad7e9c732ce0dec6ab8d15e1dd83">XV_HDMIRXSS_HANDLER_STREAM_UP</a>.</p>

</div>
</div>
<a class="anchor" id="a93b6769e137d23ae6a4fe0d61864f5cd"></a>
=======
<p>This function prints the HDMI RX SS subcore versions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a id="a93b6769e137d23ae6a4fe0d61864f5cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b6769e137d23ae6a4fe0d61864f5cd">&#9670;&nbsp;</a></span>XV_HdmiRxSs_SetDefaultPpc()</h2>

>>>>>>> upstream/master
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSs_SetDefaultPpc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will set the default in HDF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> core instance. </td></tr>
    <tr><td class="paramname">Id</td><td>is the <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> ID to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<<<<<<< HEAD
<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#af4a869965ee18d575d19b4319be08ff0">XV_HdmiRxSs::Config</a>, and <a class="el" href="struct_x_v___hdmi_rx_ss___config.html#ae3bc6c803098c13d8b8d6bce5920c10f">XV_HdmiRxSs_Config::Ppc</a>.</p>

</div>
</div>
<a class="anchor" id="a277acac840c40692bcc133be2137a6e6"></a>
=======
</div>
</div>
<a id="a277acac840c40692bcc133be2137a6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277acac840c40692bcc133be2137a6e6">&#9670;&nbsp;</a></span>XV_HdmiRxSs_SetEdidParam()</h2>

>>>>>>> upstream/master
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSs_SetEdidParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>EdidDataPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function Sets the EDID parameters in the HDMI RX SS struct. </p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<<<<<<< HEAD
<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a0275583454eea8db5b073368ae009905">XV_HdmiRxSs::EdidLength</a>, and <a class="el" href="struct_x_v___hdmi_rx_ss.html#a2ec65acd67fc707df2287d473f107814">XV_HdmiRxSs::EdidPtr</a>.</p>

</div>
</div>
<a class="anchor" id="a08f531fa69066bf7cf1491d98b5a16e0"></a>
=======
<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a0275583454eea8db5b073368ae009905">XV_HdmiRxSs::EdidLength</a>, and <a class="el" href="struct_x_v___hdmi_rx_ss.html#a2ec65acd67fc707df2287d473f107814">XV_HdmiRxSs::EdidPtr</a>.</p>

</div>
</div>
<a id="a08f531fa69066bf7cf1491d98b5a16e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f531fa69066bf7cf1491d98b5a16e0">&#9670;&nbsp;</a></span>XV_HdmiRxSs_SetHpd()</h2>

>>>>>>> upstream/master
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSs_SetHpd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the HPD on the HDMI RX. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>is a flag used to set the HPD.<ul>
<li>TRUE drives HPD high</li>
<li>FALSE drives HPD low</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<<<<<<< HEAD
<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a class="anchor" id="a7296f98d74b618438a08c0bb4d303350"></a>
=======
<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a id="a7296f98d74b618438a08c0bb4d303350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7296f98d74b618438a08c0bb4d303350">&#9670;&nbsp;</a></span>XV_HdmiRxSs_SetPpc()</h2>

>>>>>>> upstream/master
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSs_SetPpc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Ppc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will set PPC specified by user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> core instance. </td></tr>
    <tr><td class="paramname">Id</td><td>is the <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> ID to operate on. </td></tr>
    <tr><td class="paramname">Ppc</td><td>is the PPC to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<<<<<<< HEAD
<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#af4a869965ee18d575d19b4319be08ff0">XV_HdmiRxSs::Config</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#aba482869646bed3348cdd413cd011ee0">XV_HdmiRxSs::Hdcp14KeyPtr</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a5dc523135922e66f50ecc23b62ea8784">XV_HdmiRxSs::Hdcp22Lc128Ptr</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a7447a0e7065fc9e5c9e21a269b155d69">XV_HdmiRxSs::Hdcp22PrivateKeyPtr</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a6095c22e9c511e43e88375eb94a04868">XV_HdmiRxSs::HdcpEventQueue</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a190011d4c28960ab85152fb517b84dbf">XV_HdmiRxSs::HdcpIsReady</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a6a320f071cd7b8f3146fc3ede26746f4">XV_HdmiRxSs::HdcpProtocol</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>, <a class="el" href="struct_x_v___hdmi_rx_ss___config.html#ae3bc6c803098c13d8b8d6bce5920c10f">XV_HdmiRxSs_Config::Ppc</a>, <a class="el" href="xv__hdmirxss_8h.html#a700e347f920cf2a9e9e8c29ec87b828dae1ff0bdf7f9aa784e7b74a7c9f977f3a">XV_HDMIRXSS_HDCP_14</a>, <a class="el" href="xv__hdmirxss_8h.html#a700e347f920cf2a9e9e8c29ec87b828dabb5ec86bf03fe2048919736c0030bc16">XV_HDMIRXSS_HDCP_22</a>, <a class="el" href="xv__hdmirxss_8h.html#a700e347f920cf2a9e9e8c29ec87b828da60bae6631c611be7225e9993e5a9b754">XV_HDMIRXSS_HDCP_NONE</a>, <a class="el" href="xv__hdmirxss_8h.html#a882be20f612402cb4f7820f636e5922da148a0367fcdde925316c30d89739b04f">XV_HDMIRXSS_HDCP_STREAMTYPE_0</a>, <a class="el" href="xv__hdmirxss_8h.html#ae340151a671ae5e92b4ebfac8fd58251a4756f4aa51db28c98585b75d3fafe33e">XV_HDMIRXSS_KEY_HDCP14</a>, <a class="el" href="xv__hdmirxss_8h.html#ae340151a671ae5e92b4ebfac8fd58251a7005b5376717d2d54cd5b7cdbde2a81f">XV_HDMIRXSS_KEY_HDCP22_LC128</a>, and <a class="el" href="xv__hdmirxss_8h.html#ae340151a671ae5e92b4ebfac8fd58251a74420eeb523f0c229fdd7b7a15e79742">XV_HDMIRXSS_KEY_HDCP22_PRIVATE</a>.</p>

</div>
</div>
<a class="anchor" id="a6156f804fb138799bb3bd9a243dd36cf"></a>
=======
<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#af4a869965ee18d575d19b4319be08ff0">XV_HdmiRxSs::Config</a>, and <a class="el" href="struct_x_v___hdmi_rx_ss___config.html#ae3bc6c803098c13d8b8d6bce5920c10f">XV_HdmiRxSs_Config::Ppc</a>.</p>

</div>
</div>
<a id="a6156f804fb138799bb3bd9a243dd36cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6156f804fb138799bb3bd9a243dd36cf">&#9670;&nbsp;</a></span>XV_HdmiRxSs_SetStream()</h2>

>>>>>>> upstream/master
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_HdmiRxSs_SetStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>LineRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function set HDMI RX susbsystem stream parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated TMDS Clock</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<<<<<<< HEAD
<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#af4a869965ee18d575d19b4319be08ff0">XV_HdmiRxSs::Config</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>, <a class="el" href="struct_x_v___hdmi_rx_ss___config.html#ae3bc6c803098c13d8b8d6bce5920c10f">XV_HdmiRxSs_Config::Ppc</a>, <a class="el" href="xv__hdmirxss_8h.html#a801bb980bfbb34a0663bbe062e040a15a86cd289bd97f705a1b5c7327047b928c">XV_HDMIRXSS_LOG_EVT_SETSTREAM</a>, and <a class="el" href="xv__hdmirxss_8h.html#a56c28560c5de8682b22f96d40fa4e24d">XV_HdmiRxSs_LogWrite()</a>.</p>

</div>
</div>
<a class="anchor" id="a83b64b06cb5e7c1c3736c26c19adedad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSs_SetUserTimerHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XVidC_DelayHandler&#160;</td>
          <td class="paramname"><em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallbackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function installs a custom delay/sleep function to be used by the <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the HdmiSsRx instance. </td></tr>
    <tr><td class="paramname">CallbackFunc</td><td>is the address to the callback function. </td></tr>
    <tr><td class="paramname">CallbackRef</td><td>is the user data item (microseconds to delay) that will be passed to the custom sleep/delay function when it is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#ab59a7cdab6e09550acf80932ad5838b6">XV_HdmiRxSs::IsReady</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#ae099cade24fdc0ec177759907006f5ed">XV_HdmiRxSs::UserTimerPtr</a>, and <a class="el" href="struct_x_v___hdmi_rx_ss.html#ac9c0602439eff8c90c74c19129879e90">XV_HdmiRxSs::UserTimerWaitUs</a>.</p>

</div>
</div>
<a class="anchor" id="a506f350efc853af55fab90462724c5fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSs_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function starts the HDMI RX subsystem including all sub-cores that are included in the processing pipeline for a given use-case. </p>
<p>Video pipe is started from back to front </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Subsystem instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Cores are started only if the corresponding start flag in the scratch pad memory is set. This allows to selectively start only those cores included in the processing chain </dd></dl>

<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>, <a class="el" href="xv__hdmirxss_8h.html#a801bb980bfbb34a0663bbe062e040a15a458e1c5899c17758201f66c0141ff8f7">XV_HDMIRXSS_LOG_EVT_START</a>, and <a class="el" href="xv__hdmirxss_8h.html#a56c28560c5de8682b22f96d40fa4e24d">XV_HdmiRxSs_LogWrite()</a>.</p>

</div>
</div>
<a class="anchor" id="a0fa499b01743a173ef1719c45cd40a79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSs_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function stops the HDMI RX subsystem including all sub-cores Stop the video pipe starting from front to back. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Subsystem instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

<p>References <a class="el" href="xv__hdmirxss_8h.html#a801bb980bfbb34a0663bbe062e040a15ad7a14f627e46195aff377cac583106d7">XV_HDMIRXSS_LOG_EVT_STOP</a>, and <a class="el" href="xv__hdmirxss_8h.html#a56c28560c5de8682b22f96d40fa4e24d">XV_HdmiRxSs_LogWrite()</a>.</p>

</div>
</div>
<a class="anchor" id="a938e999c689d01ff3559e472f21c9757"></a>
=======
<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#af4a869965ee18d575d19b4319be08ff0">XV_HdmiRxSs::Config</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>, <a class="el" href="struct_x_v___hdmi_rx_ss___config.html#ae3bc6c803098c13d8b8d6bce5920c10f">XV_HdmiRxSs_Config::Ppc</a>, <a class="el" href="xv__hdmirxss_8h.html#a801bb980bfbb34a0663bbe062e040a15a86cd289bd97f705a1b5c7327047b928c">XV_HDMIRXSS_LOG_EVT_SETSTREAM</a>, and <a class="el" href="xv__hdmirxss_8h.html#a56c28560c5de8682b22f96d40fa4e24d">XV_HdmiRxSs_LogWrite()</a>.</p>

</div>
</div>
<a id="a938e999c689d01ff3559e472f21c9757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938e999c689d01ff3559e472f21c9757">&#9670;&nbsp;</a></span>XV_HdmiRxSs_ToggleHpd()</h2>

>>>>>>> upstream/master
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSs_ToggleHpd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function toggles the HPD on the HDMI RX. </p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<<<<<<< HEAD
<p>References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a1362a48baa691bf7a4d0f174cc699b62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XV_HdmiRx_VSIF VSIF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vendor-Specific InfoFrame structure. </p>

<p>Referenced by <a class="el" href="xv__hdmirxss_8h.html#ad9f6e6e2ae968974f36910a74ede0e2f">XV_HdmiRxSs_Reset()</a>.</p>

</div>
</div>
<a class="anchor" id="a39a18defddd74705ecd2b99d651db86c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XV_HdmiRxSs_SubCores XV_HdmiRxSs_SubCoreRepo[XPAR_XV_HDMIRXSS_NUM_INSTANCES]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define Driver instance of all sub-core included in the design. </p>

<p>Referenced by <a class="el" href="xv__hdmirxss_8h.html#a187813c9c9aa0bc87fda96af6b4b98e1">XV_HdmiRxSS_HdmiRxIntrHandler()</a>.</p>
=======
<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>
>>>>>>> upstream/master

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
